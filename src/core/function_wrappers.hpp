
#ifndef CALLBACK_PTR_HPP
#define CALLBACK_PTR_HPP

#include <functional>
#include <memory>
#include <mutex>
#include <stop_token>

#include <QPointer>
#include <QPromise>
#include <QThread>


// Internal struct with data shared between safe_callback and safe_callback_ctrl
struct safe_callback_data
{
    std::recursive_mutex mutex;             // recursive mutex - for one use case where deletion of safe_callback::m_callback triggered destruction of safe_callback_ctrl
    bool callbackAlive;

    safe_callback_data(): mutex(), callbackAlive(true) {}
};

// safe_callback is generated by safe_callback_ctrl.
// it will be a valid functor as long as safe_callback_ctrl exists.
// When safe_callback_ctrl is destroyed, all its safe_callbacks will become
// empty. operator() will do nothing.
// Usefull when calling object's method from another thread
// as we are sure target object exists (or nothing happens)
template<typename... Args>
class safe_callback final
{
    public:
        safe_callback(const std::shared_ptr<safe_callback_data>& data, std::function<void(Args...)>&& callback): m_data(data), m_callback(callback) {}
        safe_callback(const safe_callback<Args...> &) = default;

        safe_callback& operator=(const safe_callback<Args...> &) = default;

        ~safe_callback()
        {
            std::lock_guard lock(m_data->mutex);
            m_callback = std::function<void(Args...)>();            // release all possible resources held by m_callback
        }

        void operator()(Args... args) const
        {
            std::lock_guard lock(m_data->mutex);

            if (is_valid())
                m_callback(std::forward<Args>(args)...);
        }

        bool is_valid() const
        {
            return m_data->callbackAlive == true && m_callback;
        }

    private:
        std::shared_ptr<safe_callback_data> m_data;
        std::function<void(Args...)> m_callback;
};


// safe_callback_ctrl controls and creates safe_callbacks
class safe_callback_ctrl final
{
    public:
        safe_callback_ctrl(): m_data()
        {
            setup();
        }

        safe_callback_ctrl(const safe_callback_ctrl &) = delete;

        ~safe_callback_ctrl()
        {
            // safe_callback_ctrl should be reset before its destruction.
            //
            // Object owning instance of this class should call invalidate()
            // as a first action in its destructor.
            // Otherwise owner class may be partialy destructed before
            // safe_callback_ctrl is reseted which will allow
            // callbacks to work on a broken object
            auto data = m_data.load();
            assert(data.get() == nullptr || data.use_count() == 2);  // no data, or only one client - us (there are 2 copies of data - `m_data` and `data`)

            reset();
        }

        template<typename... R, typename T>
        [[nodiscard]] auto make_safe_callback(T&& callback) const
        {
            auto data = m_data.load();

            std::lock_guard lock(data->mutex);
            safe_callback<R...> callbackPtr(data, std::forward<T>(callback));

            return callbackPtr;
        }

        safe_callback_ctrl& operator=(const safe_callback_ctrl &) = delete;

        void invalidate()
        {
            reset();      // dissolve all connections
            setup();      // create new one
        }

    private:
        template<typename...>
        friend class safe_callback;

        std::atomic<std::shared_ptr<safe_callback_data>> m_data;

        void setup()
        {
            m_data.store(std::make_shared<safe_callback_data>());
        }

        void reset()
        {
            // mark all safe callbacks as invalid
            {
                // make copy of shared_ptr - reset() may be called from any thread, so we cannot operate on the same instance of m_data
                // as main thread. Operate on a copy instead which is thread safe
                auto data = m_data.load();

                // lock resource
                std::lock_guard lock(data->mutex);

                // mark resource as dead
                data->callbackAlive = false;
            }

            // replace m_data with empty shared_ptr (as result, resetting m_data)
            m_data.store(std::shared_ptr<safe_callback_data>());
        }
};


// extends QMetaObject::invokeMethod by version with arguments
template<typename Obj, typename F, typename... Args>
void invokeMethod(Obj* object, const F& method, Args&&... args) requires std::is_base_of<QObject, Obj>::value
{
    QMetaObject::invokeMethod(object, [object, method, ...args = std::forward<Args>(args)]() mutable
    {
        (object->*method)(std::forward<Args>(args)...);
    });
}


// like invokeMethod but postponed
template<typename Obj, typename F, typename... Args>
void invokeMethodLater(Obj* object, const F& method, Args&&... args) requires std::is_base_of<QObject, Obj>::value
{
    QMetaObject::invokeMethod(object, [object, method, ...args = std::forward<Args>(args)]() mutable
    {
        (object->*method)(std::forward<Args>(args)...);
    }, Qt::QueuedConnection);
}


// Works as extended invokeMethod but waits for results
template<typename T, typename ObjT, typename F, typename... Args>
requires std::is_base_of_v<QObject, ObjT>
auto invoke_and_wait(QPointer<ObjT> object, const F& function, Args&&... args)
{
    QPromise<T> promise;
    QFuture<T> future = promise.future();

    call_from_object_thread(object, [&promise, &function, &args...]()
    {
        promise.start();
        promise.addResult(function(args...));
        promise.finish();
    });

    future.waitForFinished();

    return future.result();
}


// call_from_object_thread uses Qt mechanisms to invoke function in another thread
// (thread of 'object' object)
template<typename F, typename ObjT, typename... Args>
requires std::is_base_of_v<QObject, ObjT>
void call_from_object_thread(QPointer<ObjT> object, const F& function, Args&&... args)
{
    if (object.data() != nullptr)
    {
        if constexpr (std::is_member_function_pointer_v<F>)
            QMetaObject::invokeMethod(object.data(), [object, function, args...]()
            {
                ((*object).*function)(args...);
            });
        else
            QMetaObject::invokeMethod(object.data(), [function, args...]()
            {
                function(args...);
            });
    }
}


template<typename F, typename... Args>
void call_from_this_thread(QThread* thread, const F& function, Args&&... args)
{
    QMetaObject::invokeMethod(thread, [function, args...]()
    {
        function(args...);
    });
}


// construct a functor which invoked will invoke encapsulated
// functor in another thread
template<typename... Args, typename ObjT, typename F>
requires std::is_base_of_v<QObject, ObjT>
[[nodiscard]] std::function<void(Args...)> make_cross_thread_function(ObjT* object, const F& function)
{
    std::function<void(Args...)> result = [=](Args&&... args)
    {
        call_from_object_thread(QPointer<ObjT>(object), function, std::forward<Args>(args)...);
    };

    return result;
}


template<typename... Args, typename F>
[[nodiscard]] std::function<void(Args...)> make_cross_thread_function(QThread* thread, const F& function)
{
    std::function<void(Args...)> result = [=](Args&&... args)
    {
        call_from_this_thread(thread, function, std::forward<Args>(args)...);
    };

    return result;
}


// construct a functor which invoked will invoke a method
// (slot) of given object. Will do nothing when given object is destroyed.
// Similar to safe_callback_ctrl (but method will be invoked in target's thread)
template<typename ObjT, typename R, typename ...Args>
requires std::is_base_of_v<QObject, ObjT>
[[nodiscard]] auto queued_slot(ObjT* obj, R(ObjT::*method)(Args...))
{
    QPointer<ObjT> objPtr(obj);

    return [objPtr, method](Args... args)
    {
        ObjT* object = objPtr.data();

        if (object)
            invokeMethod(object, method, std::forward<Args>(args)...);
    };
}

// construct a functor which invoked will invoke a method
// (slot) of given object. Will do nothing when given object is destroyed.
// Similar to safe_callback_ctrl (but uses Qt mechanism to guarantee (?) threadsafety)
// In contrast to queued_slot() method is invoked in caller's thread
template<typename ObjT, typename R, typename ...Args>
requires std::is_base_of_v<QObject, ObjT>
[[nodiscard]] std::function<void(Args...)> direct_slot(ObjT* obj, R(ObjT::*method)(Args...))
{
    QPointer<ObjT> objPtr(obj);

    return [objPtr, method](Args... args)
    {
        ObjT* object = objPtr.data();

        if (object)
            (object->*method)(std::forward<Args>(args)...);
    };
}

#endif
