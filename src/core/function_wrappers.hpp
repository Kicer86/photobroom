
#ifndef CALLBACK_PTR_HPP
#define CALLBACK_PTR_HPP

#include <functional>
#include <memory>
#include <mutex>
#include <stop_token>

#include <QPointer>
#include <QThread>

// Internal struct with data shared between safe_callback and safe_callback_ctrl
struct safe_callback_data
{
    std::mutex mutex;
    bool callbackAlive;

    safe_callback_data(): mutex(), callbackAlive(true) {}
};

// safe_callback is generated by safe_callback_ctrl.
// it will be a valid functor as long as safe_callback_ctrl exists.
// When safe_callback_ctrl is destroyed, all its safe_callbacks will become
// empty. operator() will do nothing.
// Usefull when calling object's method from another thread
// as we are sure target object exists (or nothing happens)
template<typename... Args>
class safe_callback final
{
    public:
        safe_callback(const std::shared_ptr<safe_callback_data>& data, std::function<void(Args...)>&& callback): m_data(data), m_callback(callback) {}
        safe_callback(const safe_callback<Args...> &) = default;

        safe_callback& operator=(const safe_callback<Args...> &) = default;

        virtual ~safe_callback() = default;

        void operator()(Args... args) const
        {
            std::lock_guard<std::mutex> lock(m_data->mutex);

            if (is_valid())
                m_callback(std::forward<Args>(args)...);
        }

        bool is_valid() const
        {
            return m_data->callbackAlive == true && m_callback;
        }

    private:
        std::shared_ptr<safe_callback_data> m_data;

        std::function<void(Args...)> m_callback;
};


// safe_callback_ctrl controls and creates safe_callbacks
class safe_callback_ctrl final
{
    public:
        safe_callback_ctrl(): m_data()
        {
            setup();
        }

        safe_callback_ctrl(const safe_callback_ctrl &) = delete;

        ~safe_callback_ctrl()
        {
            // safe_callback_ctrl should be reset before its destruction.
            //
            // Object owning instance of this class should call invalidate()
            // as a first action in its destructor.
            // Otherwise owner class may be partialy destructed before
            // safe_callback_ctrl is reseted which will allow
            // callbacks to work on a broken object
            assert(m_data.get() == 0 || m_data.use_count() == 1);  // no data, or only one client - us

            reset();
        }

        template<typename... R, typename T>
        auto make_safe_callback(T&& callback) const
        {
            safe_callback<R...> callbackPtr(m_data, std::forward<T>(callback));

            return callbackPtr;
        }

        safe_callback_ctrl& operator=(const safe_callback_ctrl &) = delete;

        void invalidate()
        {
            reset();      // dissolve all connections
            setup();      // create new one
        }

    private:
        template<typename...>
        friend class safe_callback;

        std::shared_ptr<safe_callback_data> m_data;

        void setup()
        {
            m_data = std::make_shared<safe_callback_data>();
        }

        void reset()
        {
            // mark all safe callbacks as invalid
            {
                // lock resource
                std::lock_guard<std::mutex> lock(m_data->mutex);

                // mark resource as dead
                m_data->callbackAlive = false;
            }

            // detach from existing safe callbacks
            m_data.reset();
        }
};


// extends QMetaObject::invokeMethod by version with arguments
template<typename Obj, typename F, typename... Args>
void invokeMethod(Obj* object, const F& method, Args&&... args) requires std::is_base_of<QObject, Obj>::value
{
    QMetaObject::invokeMethod(object, [object, method, args...]()
    {
        (object->*method)(args...);
    });
}


// call_from_object_thread uses Qt mechanisms to invoke function in another thread
// (thread of 'object' object)
template<typename F, typename ObjT, typename... Args>
requires std::is_base_of_v<QObject, ObjT>
void call_from_object_thread(QPointer<ObjT> object, const F& function, Args&&... args)
{
    if (object.data() != nullptr)
    {
        if constexpr (std::is_member_function_pointer_v<F>)
            QMetaObject::invokeMethod(object.data(), [object, function, args...]()
            {
                ((*object).*function)(args...);
            });
        else
            QMetaObject::invokeMethod(object.data(), [function, args...]()
            {
                function(args...);
            });
    }
}


template<typename F, typename... Args>
void call_from_this_thread(QThread* thread, const F& function, Args&&... args)
{
    QMetaObject::invokeMethod(thread, [function, args...]()
    {
        function(args...);
    });
}


// construct a functor which invoked will invoke encapsulated
// functor in another thread
template<typename... Args, typename ObjT, typename F>
requires std::is_base_of_v<QObject, ObjT>
std::function<void(Args...)> make_cross_thread_function(ObjT* object, const F& function)
{
    std::function<void(Args...)> result = [=](Args&&... args)
    {
        call_from_object_thread(QPointer<ObjT>(object), function, std::forward<Args>(args)...);
    };

    return result;
}


template<typename... Args, typename F>
std::function<void(Args...)> make_cross_thread_function(QThread* thread, const F& function)
{
    std::function<void(Args...)> result = [=](Args&&... args)
    {
        call_from_this_thread(thread, function, std::forward<Args>(args)...);
    };

    return result;
}


// construct a functor which invoked will invoke a method
// (slot) of given object. Will do nothing when given object is destroyed.
// Similar to safe_callback_ctrl (but method will be invoked in target's thread)
template<typename ObjT, typename R, typename ...Args>
requires std::is_base_of_v<QObject, ObjT>
auto queued_slot(ObjT* obj, R(ObjT::*method)(Args...))
{
    QPointer<ObjT> objPtr(obj);

    return [objPtr, method](Args... args)
    {
        ObjT* object = objPtr.data();

        if (object)
            invokeMethod(object, method, std::forward<Args>(args)...);
    };
}

// construct a functor which invoked will invoke a method
// (slot) of given object. Will do nothing when given object is destroyed.
// Similar to safe_callback_ctrl (but uses Qt mechanism to guarantee (?) threadsafety)
// In contrast to queued_slot() method is invoked in caller's thread
template<typename ObjT, typename R, typename ...Args>
requires std::is_base_of_v<QObject, ObjT>
std::function<void(Args...)> direct_slot(ObjT* obj, R(ObjT::*method)(Args...))
{
    QPointer<ObjT> objPtr(obj);

    return [objPtr, method](Args... args)
    {
        ObjT* object = objPtr.data();

        if (object)
            (object->*method)(std::forward<Args>(args)...);
    };
}

template<typename T>
using StoppableTaskCallback = std::function<void(const T&)>;
/**
 * @brief run @p task and then call @p callback with result if @ref stop_source was not stopped
 * @param stop_source used to get stop_token passed to @p task. @p task should take use of it to stop work when needed.
 * @param task stoppable task to be executed. @p task should call provided callback with result whem job is done
 * @param callback callback provided by user to be called when @p task is done
 *
 * stoppableTask() will wrap @p callback using @ref safe_callback_ctrl to make sure it won't be called when @p stop_source was stopped.
 * Therefore it is safe to destroy any objects used by @p callback before @p task is done.
 * @note All objects in @p task need to be valid during execution.
 */
template<typename R, typename Callback>
void stoppableTask(const std::stop_source& stop_source, std::function<void(const std::stop_token &, StoppableTaskCallback<R>)> task, Callback callback)
{
    // Helper class containing safe_callback_ctrl related stuff.
    // It's purpose is to live as long as task and callback are alive to make sure
    // safe_callback_ctrl and std::stop_callback are alive as well (used by stop_token stop request).
    class Context final
    {
    public:
        explicit Context(std::stop_token stop_token)
            : stop_callback(
                stop_token,
                [this]
                {
                    ctrl.invalidate();
                    callback_invalidated = true;
                })
        {

        }

        ~Context()
        {
            // task should called callback (if valid)
            assert(callback_called || callback_invalidated);

            // ctrl needs to be invalidated before destruction
            ctrl.invalidate();
        }

        safe_callback_ctrl ctrl;
        std::stop_callback<std::function<void()>> stop_callback;
        bool callback_called = false;
        bool callback_invalidated = false;
    };

    const auto stop_token = stop_source.get_token();
    auto context = std::make_shared<Context>(stop_token);

    // inject context into callback so it will live with it and wrap it with safe_callback so
    // it can be invalidated when stop (on stop_token) is requested.
    auto safe_callback = context->ctrl.template make_safe_callback<R>(
        [context, callback](const R& r)
        {
            callback(r);

            // mark callback called
            context->callback_called = true;
        });

    task(stop_token, safe_callback);
};


#endif
